## This macro executes 'func' on every element in list and prints 'delimiter' between
#  macro foreach(list, func, delimiter) 
#     for element in list
         {{- func(element) -}}
#        if not loop.last
            {{- delimiter -}}
#        endif
#     endfor
#  endmacro



##- Recursive macro for each node value
#  macro each_node(node)
#     if node.isVariable()
#        if node.tokenId() == 'INT'
            ## A global variable
            {{- node.value() -}}
#        else
            ## A global variable
            {{- "z_" + node.value() -}}
#        endif
#     elif node.isTuple()
         ## A tuple
         {{- "(" + foreach(node, each_node, ", ") + ")" -}}      
#     elif node.isList()
         ## A list
         {{- "[" + foreach(node, each_node, ", ") + "]" -}}      
#     elif node.isApplication()
         ## A function call
         {{- "(z_" ~ node + " " + foreach(node, each_node, " ") + ")" -}} 
#     elif node.isLambda()
         ## A lambda function
         {{- "\\\\(z_" + node[0]|join(' z_') + ") -> " + each_node(node[1]) -}}
#     endif
# endmacro



## Define a haskell function for every definition in ast
#  for definition in definitions
#     if definition[1].isLambda()
      {{- "z_" ~ definition[0] ~ " (z_" + definition[1][0]|join(', z_') + ") = " + each_node(definition[1][1]) + "\n\n" -}}
#     else
      {{- "z_" ~ definition[0] ~ " = " + each_node(definition[1]) + "\n\n" -}}
#     endif
#  endfor

## Library functions
# if library
z_true = True
z_false = False
z_and a b = and [a, b]
z_or  a b = or [a, b]
z_not a = not a

z_ifelse :: Bool -> a -> a -> a
z_ifelse True a b = a
z_ifelse False a b = b


z_add = (+)
z_sub = (-)
z_mul = (*)
z_div = (/)
# endif
